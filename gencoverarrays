"""
Created on Sat May  29 12:16:00 2021

@author: KirstenLNelson

A very naive Python program to generate all covering arrays with parameters 
CA(N;t,k,v) where v=2, and you set your desired t, k and N.
"""

from time import time
import itertools

# is_CA: Matrix Integer -> Boolean
# Purpose: check if a matrix is a covering array for a given strength
# ------------------------------------------------------
def is_CA(array, t):
# ------------------------------------------------------
    '''
    >>> is_CA([[0,0,1,1],[0,1,0,1]], 2)
    True
    >>> is_CA([[0,0,1,1],[0,1,0,1],[1,0,1,0]], 2)
    False
    >>> is_CA([[0,0,0,1,1],[0,1,0,0,1],[1,0,0,0,1],[0,0,1,0,1]], 2)
    True
    >>> is_CA([[0,0,0,1,1],[0,1,0,0,1],[1,0,0,0,1],[0,0,1,0,1],[0,1,0,0,1]], 2)
    False
    >>> is_CA([[0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1]], 3)
    True
    >>> is_CA([[0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1],[0,1,0,1,0,1,0,1]], 3)
    False
    >>> is_CA([[(0,0,0,0,0,1,1,1,1,1),(0,0,0,1,1,1,1,1,0,0),(0,1,0,1,0,1,1,0,0,1),(0,1,1,0,1,1,0,0,1,0)]])
    True
    '''
# The array may not be full size yet    
    len_array = len(array)
# We can only test the coverage if the number of columns is as big as the 
# strength, so just let it pass the test until then
    if len_array < t:
        return True
# We need to compare the new column to each one already in the array
    for t_set in itertools.combinations(range(len_array), t):
        if not is_t_set_covered(array, t_set):
            return False
    return True

# is_t_set_covered: matrix, list -> Boolean
# Purpose: given a matrix and a set of columns, check if they are covered
# ------------------------------------------------------    
def is_t_set_covered(array, t_set):
# ------------------------------------------------------
# Examples:
    '''
    >>> is_t_set_covered([[0,0,1,1],[0,1,0,1],[1,0,1,0]], (1,2))
    False
    >>> is_t_set_covered([[0,0,1,1],[0,1,0,1],[1,0,1,0]], (0,1))
    True
    >>> is_t_set_covered([[0,0,0,1,1],[0,1,0,0,1],[1,0,0,0,1],[0,0,1,0,1]], (0,3))
    True
    >>> is_t_set_covered([[0,0,0,1,1],[0,1,0,0,1],[1,1,0,1,0],[0,0,1,0,1]], (2,3))
    False
    >>> is_t_set_covered([[0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1]], (0,1,2))
    True
    >>> is_t_set_covered([[0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1],[0,1,0,1,0,1,0,1]], (1,2,3))
    False
    '''
    t = len(t_set)
    row_set = []
# Cycle through the k column-rows of the array    
    for j in range(0, len(array[0])):
# Pull out the t-tuple and put it in the set  
        curr_tuple = []
        for m in range(0, len(t_set)):
            curr_tuple.append(array[t_set[m]][j])
        row_set.append([curr_tuple])
    row_set.sort()
# Eliminate the duplicates
    row_set = [i for n, i in enumerate(row_set) if i not in row_set[:n]]
# We need the number of unique tuples to be equal to v^t
    if len(row_set) == v**t:
        return True
    else:
        return False
        
# search_CA: matrix, integer -> recursive call
# Purpose: a recursive search for covering arrays        
# ------------------------------------------------------
def search_CA(temp_array, i):
# ------------------------------------------------------
    global number_found
    global branches
    v_div_N = False
    if len(base_row) % v == 0:
        v_div_N = True
    if i == k and is_CA(temp_array, t):
        number_found = number_found + 1
        if number_found == 1:
            print('I found you this array: ', temp_array)
        branches = branches + 1
    else:
        branches = branches + 1
# This is a terrible solution for the fact that we are getting each possible
# row four times more often than we need it.
        for column in list(set(itertools.permutations(base_row))):
# If v divides N, we can re-label a column to have a 0 in the first entry
            if (not v_div_N) or (v_div_N and column[0] == 0):
                new_array = temp_array[:]
# We want our rows to be in increasing order
                if column > new_array[-1]:
                    new_array.append(column)
                    if is_CA(new_array, t):
                        search_CA(new_array, i+1)

# ------------------------------------------------------
# Main program begins here
# ------------------------------------------------------
# Run unit tests
doctest.testmod()
# ------------------------------------------------------
# Set your parameters here
# ------------------------------------------------------
# Set this to your desired parameter k, the number of factors
k = 5
# Set this to your desired parameter t, the strength of the array
t = 2
# Set this to the size of your alphabet, v
v = 3
# Set this to your desired first column; normally a balance of alphabet 
# characters. If N is not divisible by v, put extra characters near the front.
base_row = (0,0,0,0,1,1,1,1,2,2,2)
# ------------------------------------------------------
# Here we go!
# ------------------------------------------------------
start_time = time()
number_found = 0
branches = 0
search_CA([base_row], 1)
print('number_found is: ', number_found)
print('number of branches is: ', branches)
end_time = time()
print('in: ', end_time - start_time, 'seconds.')

